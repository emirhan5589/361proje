
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module EE314_GROUP38(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD,

	//////////// KEY //////////
	input                [2:0]              KEY,

        // GPIO for Player 2
        input                [3:0]              GPIO_P2,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire [2:0] vga_r_3bit_internal; 
    wire [2:0] vga_g_3bit_internal; 
    wire [1:0] vga_b_2bit_internal; 


	 
	 wire timer_enable;
wire timer_reset;
wire [7:0] game_time_seconds;
wire winner_p1, winner_p2, game_is_draw;

wire [2:0] p1_health, p2_health;

    // Internal Wires
	 
    wire p1_left;
    wire p1_right;
    wire p1_attack;
    wire p2_left;
    wire p2_right;
    wire p2_attack;
	 
    
	 wire clk_25mhz_pixel;
		wire clk_game;
		
    wire [9:0] current_pixel_x;
    wire [9:0] current_pixel_y;
    wire current_display_enable;
	
    wire [9:0] char_x_pos;
    wire [9:0] char_y_pos;
    wire [9:0] char_width;
    wire [9:0] char_height;
    wire [7:0] char_color_332;	// Player 1 color
    // Player 2 sprite wires
    wire [9:0] char2_x_pos;
    wire [9:0] char2_y_pos;
    wire [9:0] char2_width;
    wire [9:0] char2_height;
    wire [7:0] char2_color_332;

    wire [7:0] background_pixel_color_332;  // Output of background_generator
    wire [7:0] char_rendered_pixel_color_332;        // Color output of character_renderer
    wire       char_is_visible_at_pixel;    // Visibility flag from character_renderer
    wire [7:0] final_pixel_color_to_vga_332; // Output of graphics_mixer

    wire [1:0] attack_phase;
    wire [1:0] attack_phase_p2;
	 
	   wire frame_sync;
    wire vblank;

game_clocks clocks_inst (
    .clk_50Mhz_in (CLOCK_50),
    .reset_in     (1'b0),
    .sw1_in       (SW[1]),
    .key_step_in  (1'b0),
	.clk_25Mhz_out(clk_25mhz_pixel),
	.clk_60Hz_out(clk_game),
	.frame_sync_in(frame_sync)
	);
	 
    input_handler inputs_inst (
        .clk(CLOCK_50),
        .reset(1'b0),
        .key_p1_left_n(KEY[0]),
        .key_p1_right_n(KEY[1]),
        .key_p1_attack_n(KEY[2]),
        .gpio_p2_left(GPIO_P2[0]),
        .gpio_p2_right(GPIO_P2[1]),
        .gpio_p2_attack(GPIO_P2[2]),
        .p1_left(p1_left),
        .p1_right(p1_right),
        .p1_attack(p1_attack),
        .p2_left(p2_left),
        .p2_right(p2_right),
        .p2_attack(p2_attack)
    );
	 
    player_logic player1_logic_inst (
    .clk_game(clk_game),
    .reset(reset_gameplay),  // CHANGE THIS: reset during menu/countdown
    .move_left_cmd_in(p1_left && (current_game_state == 3'b010)), // Only in gameplay
    .move_right_cmd_in(p1_right && (current_game_state == 3'b010)), // Only in gameplay
    .p1_attack_cmd_in(p1_attack && (current_game_state == 3'b010)), // Only in gameplay
    .init_x_pos(10'd304),
    .char_x_pos_out(char_x_pos),
    .char_y_pos_out(char_y_pos),
    .char_width_out(char_width),
    .char_height_out(char_height),
    .char_color_out_332(char_color_332),
    .attack_phase_out(attack_phase)
);

    player_logic player2_logic_inst (
    .clk_game(clk_game),
    .reset(reset_gameplay),
    .move_left_cmd_in(p2_left && (current_game_state == 3'b010)),
    .move_right_cmd_in(p2_right && (current_game_state == 3'b010)),
    .p1_attack_cmd_in(p2_attack && (current_game_state == 3'b010)),
    .init_x_pos(10'd500),
    .char_x_pos_out(char2_x_pos),
    .char_y_pos_out(char2_y_pos),
    .char_width_out(char2_width),
    .char_height_out(char2_height),
    .char_color_out_332(char2_color_332),
    .attack_phase_out(attack_phase_p2)
);
	 
    // --- Test Pattern Generator ---
    background_generator background_gen_inst (      
        .pixel_clk(clk_25mhz_pixel),             
        .reset(1'b0),
        .display_enable(current_display_enable),
        .pixel_x(current_pixel_x),               
        .pixel_y(current_pixel_y),               
        .color_out_332(background_pixel_color_332) 
    );
	 
    character_renderer char_render_inst (
        .display_enable(current_display_enable),
        .current_pixel_x(current_pixel_x),
        .current_pixel_y(current_pixel_y),
        .char_x_pos_in(char_x_pos),             
        .char_y_pos_in(char_y_pos),             
        .char_width_in(char_width),             
        .char_height_in(char_height),           
        .char_color_in_332(char_color_332),     
        .char_pixel_color_out_332(char_rendered_pixel_color_332),
        .char_is_visible_at_pixel_out(char_is_visible_at_pixel),
		  .attack_phase_in(attack_phase)
    );
	 
	 

graphics_mixer mixer_inst (
    .display_enable(current_display_enable),
    .pixel_x(current_pixel_x),
    .pixel_y(current_pixel_y),
    .background_color_in_332(background_pixel_color_332),
    .char1_x_pos(char_x_pos),
    .char1_y_pos(char_y_pos),
    .char1_width(char_width),
    .char1_height(char_height),
    .char1_color_in_332(char_color_332),
    .char1_attack_phase(attack_phase),

    .char2_x_pos(char2_x_pos),
    .char2_y_pos(char2_y_pos),
    .char2_width(char2_width),
    .char2_height(char2_height),
    .char2_color_in_332(char2_color_332),
    .char2_attack_phase(attack_phase_p2),
    .current_game_state(current_game_state),     // ADD THIS
    .menu_color_in_332(menu_color_332),          // ADD THIS  
    .menu_pixel_visible(menu_pixel_visible),     // ADD THIS
    .final_pixel_color_out_332(final_pixel_color_to_vga_332)
);

    // --- VGA Controller ---
    vga_driver vga_controller_inst (
        .pixel_clk(clk_25mhz_pixel),
        .reset(1'b0),
        .color_in_332(final_pixel_color_to_vga_332), 

        // Outputs for pattern generator's reference
        .pixel_x(current_pixel_x),
        .pixel_y(current_pixel_y),
        .display_enable(current_display_enable),

        // Outputs to physical VGA connector pins
        .vga_hsync(VGA_HS),
        .vga_vsync(VGA_VS),
        .vga_r_out(vga_r_3bit_internal),
        .vga_g_out(vga_g_3bit_internal),
        .vga_b_out(vga_b_2bit_internal),
		  .frame_sync(frame_sync),     
        .vblank(vblank) 
    );




	 
	 
	 
	 
// Game state wires
wire [2:0] current_game_state;
wire [7:0] countdown_value;
wire game_mode_1p;
wire start_gameplay;
wire reset_gameplay;
wire p1_any_button_pressed;

// Menu system wires
wire menu_active;
wire countdown_active;
wire [7:0] menu_color_332;
wire menu_pixel_visible;

// State assignments
assign menu_active = (current_game_state == 3'b000);      // STATE_MENU
assign countdown_active = (current_game_state == 3'b001); // STATE_COUNTDOWN
assign p1_any_button_pressed = p1_left || p1_right || p1_attack;

// Add game state controller instance
game_state_controller game_state_ctrl (
    .clk_game(clk_game),
    .reset(1'b0),
    .p1_any_button_pressed(p1_any_button_pressed),
    .sw0_game_mode(SW[0]),
    .game_over_condition(1'b0),  // TODO: Connect to actual game over logic
    .winner_p1(1'b0),            // TODO: Connect to actual winner logic
    .winner_p2(1'b0),            // TODO: Connect to actual winner logic
    .current_game_state(current_game_state),
    .countdown_value(countdown_value),
    .game_mode_1p(game_mode_1p),
    .start_gameplay(start_gameplay),
    .reset_gameplay(reset_gameplay),
	 .timer_enable(timer_enable),             // ADD THIS
    .timer_reset(timer_reset)
);

// Update menu controller with better positioning
menu_controller menu_ctrl (
    .pixel_clk(clk_25mhz_pixel),
    .reset(1'b0),
    .display_enable(current_display_enable),
    .pixel_x(current_pixel_x),
    .pixel_y(current_pixel_y),
    .menu_active(menu_active),
    .countdown_active(countdown_active),
    .countdown_value(countdown_value),
    .game_mode_1p(game_mode_1p),
    .menu_color_out_332(menu_color_332),
    .menu_pixel_visible(menu_pixel_visible)
);

// Game timer instance
game_timer timer_inst (
    .clk_game(clk_game),
    .reset(1'b0),
    .timer_enable(timer_enable),
    .timer_reset(timer_reset),
    .seconds_count(game_time_seconds)
);


// Seven-segment controller instance
seven_segment_controller seg7_ctrl (
    .clk_game(clk_game),
    .reset(1'b0),
    .current_game_state(current_game_state),
    .game_mode_1p(game_mode_1p),
    .game_time_seconds(game_time_seconds),
    .winner_p1(winner_p1),                  // TODO: Connect to actual game logic
    .winner_p2(winner_p2),                  // TODO: Connect to actual game logic  
    .game_is_draw(game_is_draw),            // TODO: Connect to actual game logic
    .hex0_out(HEX0),
    .hex1_out(HEX1),
    .hex2_out(HEX2),
    .hex3_out(HEX3),
    .hex4_out(HEX4),
    .hex5_out(HEX5)
);

// Temporary assignments for winner logic (to be implemented later)
assign winner_p1 = 1'b0;
assign winner_p2 = 1'b0;
assign game_is_draw = 1'b0;

// Temporary health assignments (for testing)
assign p1_health = 3'd3;  // Full health for now
assign p2_health = 3'd3;  // Full health for now


// LED Controller instance
led_controller led_ctrl (
    .clk_game(clk_game),
    .reset(1'b0),
    .current_game_state(current_game_state),
    .p1_health(p1_health),               // TODO: Connect to actual health logic
    .p2_health(p2_health),               // TODO: Connect to actual health logic
    .leds_out(LEDR)
);


//=======================================================
//  Structural coding
//=======================================================
assign VGA_BLANK_N = current_display_enable; 
assign VGA_CLK     = clk_25mhz_pixel; 
assign VGA_SYNC_N  = 1'b1;

assign VGA_R = {vga_r_3bit_internal, vga_r_3bit_internal[2:1], vga_r_3bit_internal[2:0]}; 
assign VGA_G = {vga_g_3bit_internal, vga_g_3bit_internal[2:1], vga_g_3bit_internal[2:0]};
assign VGA_B = {vga_b_2bit_internal, vga_b_2bit_internal, vga_b_2bit_internal, vga_b_2bit_internal};


endmodule
